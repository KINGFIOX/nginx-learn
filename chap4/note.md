# chap4 - 服务器程序框架初步

## chap4 - 01 - 服务器程序目录规划、makefile 编写

### 信号高级认识范例

在触发 sigusr1 信号并因此 sleep 了 10s 钟期间，就算多次触发 sigusr1 信号，也不会重新触发 sigusr1 信号对应的信号处理函数，
而是会等待上一个 sigusr 信号处理函数执行完毕，才执行第二次 sigusr1 信号处理函数。

换句话说：信号处理函数被调用时，操作系统案例的新信号屏蔽字，自动包括了正在被传递的信号，
因此，保证了在处理一个给定信号的时候，如果这个信号再次发生，那么它会阻塞到前一个信号处理结束为止。

另外，不管发送了多少次`kill -usr1`信号，在该信号处理函数执行期间，
后续所有的 sigusr1 信号统统归结为 1 次。

比如：当前执行 sigusr1 信号的处理程序但没有执行完毕，这个时候，你又发送来了 5 次 sigusr1 信号，
那么当 sigusr1 信号处理程序执行完毕（解除阻塞），sigusr1 信号的处理程序也只会被调用一次（而不会分别调用 5 次 sigusr1 信号的处理函数）

sleep 是可以被信号打断的。
如果在 sig1 中 sleep 10 秒，但是又来了 sig2 信号，
这个时候会进入 sig2 的处理函数中，sig2 退出后，sig1 处理函数中，不会继续 sleep 了。

如果已经 sig1 --> sig2 后，
如果我们再来很多 sig1 和 sig2，这两个信号被会被阻塞。

既然是在执行 usr1 信号处理程序执行的时候，来了 usr2，导致在又去执行了 usr2 信号处理程序，这就意味着，
只有 usr2 信号处理程序执行完毕，才会返回到 sur1 信号处理程序。
只有 usr1 信号处理程序执行完毕了，才会最后返回到 main 中

如果我希望在黑醋栗 sigusr1 信号，执行 usr1 信号处理程序的时候，如果来了 sigusr2 信号，
我不希望调到 usr2 信号处理函数中，我可以用 sigprocmask 来屏蔽信号。

### 服务器架构初步

#### 目录结构规划

#### 编译工具 make 的使用概述

#### makefile 脚本的用法介绍

#### makefile 脚本具体实现讲解
