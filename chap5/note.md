# chap5 - 网络通讯实战

## chap5 - 01 - TCP/IP 协议妙趣横生

### 客户端 与 服务器

客户端，服务端 都是 一个程序

#### 解析一个浏览器访问网页的过程

#### 客户端 服务器 角色 规律总结

1. 数据通讯总在两端进行，其中一端叫做客户端，另一端叫做服务器端

2. 总有一方要先发起数据，这发起第一个数据包的一段，就叫客户端; 被动接受第一个数据包这端，就叫服务器端

3. 连接建立起来，数据双向流动，这叫双工【你可以发数据包给我，我也可以发数据包给你】

4. 既然服务器端是被动接收连接，那么客户端必须能够找到服务器在哪里

比方说，我的浏览器要访问 taobao，我需要知道 taobao 服务器的地址【ip 地址，192.168.1.1】，
以及 taobao 服务器的姓名【端口号，这是一个 无符号数字，范围 0 ～ 65535】，浏览器默认是访问 80 端口（http）

taobao 服务器【nginx 服务器】会调用 listen() 函数监听 80 端口

在编写网络通讯程序时，只需要指定 taobao 服务器的 ip 地址 和 淘宝服务器的端口号，就能够跟 taobao 服务器 进行 通讯

5. epoll 技术可以支持 数十万 的连接

### 网络模型

#### OSI 七层网络模型

哪 7 层？顺口溜：物【物理层】 链【数据链路层】 网【网络层】 传【传输层】 会【会话层】 表【表示层】 应【应用层】

open system interconnect（osi）：开放式系统互联：ISO 国际标准化组织，在 1985 年研究出来的一个模型

物理层：网卡、硬件等

应用层：为应用程序提供服务

把一个要发送出去的数据包，从里到外裹了 7 层; 最终把包裹了 7 层的数据包发送了出去

（这个会在《计网》中应该会 详细学习）

#### TCP/IP 协议 四层模型

transfer control protocol（传输控制协议） / internet protocol （网际协议） (TCP/IP)

tcp/ip 实际上是 一组 协议 的代名词，而不仅仅是一个协议

- 链路层（物、链） --> ARP、以太网帧、RARP
- 网络层（网） --> ICMP、IP、IGMP
- 传输层（传）--> TCP、UDP
- 应用层（会、表、应） --> 用户进程

把数据包，裹了 4 层

TCP/IP，其实每一层都对应着一些协议

重点理解：

以太网帧 <--> IP <--> TCP <--> 用户进程

#### TCP/IP 协议的解释和比喻

要发送 abc --> 加 tcp 头 --> 加 ip 头 --> 加 以太网帧 头和尾

加上 3 头 1 尾

![tcpip](image/tcpip.png)

### 最简单的用户端 和 服务器程序实现代码

下面这两个 服务器程序、客户端程序，只具备演示价值

推荐书籍：《unix 网络编程》

#### 套接字 socket 概念

socket（套接字）：就是一个数字，通过调用 socket()函数生成的，这个数字具有唯一性;
当调用 socket()，操作系统给你返回的话，这个数字会一直给你用，直到你调用 close()，
把这个数字关闭（有点 fd 的意思），才会把这个数字回收。

unix 哲学：一切皆文件，所以我们也把这个 socket 也堪称是文件描述符，
我们可以用 socket 收发数据：send()，recv()

#### 一个简单的服务端 通讯程序 范例

注意：服务器端 与 客户端 程序是不一样的。

listenfd = socket() --> bind() --> listen() --> connfd = accept()【等待客户端连我，阻塞】
--> write(connfd) --> close(connfd) --> close(listenfd)

#### IP 地址 简单谈

ipv4 地址：理解成现实社会中的 居住地址

#### 一个简单的客户端 通讯程序 范例

建立连接时，双方彼此都要有 ip 地址、端口号。

连接一旦建立起来，那么双方的通讯【双工收发】，
就只需要用双方彼此对应的 socket 即可。

#### 客户端 服务器程序 综合演示 和 调用流程图

### TCP 和 UDP 的区别

我们可以看到：UDP、TCP 都是 “传输层”

UDP：不可靠，无连接的（有种无线网络的感觉），
发送速度特别快，但无法确保数据的可靠性。
可能后发出的数据先到达。

TCP：可靠，有连接的（有种有线网络的感觉），
TCP 可靠，必要要更多的系统资源确保数据传输的可靠。
得到的呃好处就是：只要不断线，传输给对象的数据，一定正确，不丢失，不重复，按顺序到达对端

应用场景：

- tcp: 文件传输，一般 TCP 对 UDP 用的范围 和 场景更广
- udp: qq 聊天信息，聊天信息巨大，服务器懒得整，但是 qq 内部有一些算法导致丢包率下降

《TCP/IP 协议详解》

## chap5 - 02 - TCP 三次握手详解、telnet、wireshark 示范

### TCP 连接的三次握手

只有 tcp 有三次握手【连接的时候】

#### 最大传输单元 MTU

mtu (maximum transfer unit)，最大传输单元

每个数据包 包含的数据最多可以有多少个字节？1.5k 左右（真正传输的数据，大概是 1.4k 左右，加上一 3 头 1 尾之类的）

你要发送 100k，操作系统内部会把你这 100k 数据拆分成若干个数据包，
每个数据包大概 1.5k 之内。

我们只需要有：拆包、组包 这个过程就行了，细节不用掌握

我们拆开的包，各自传输的路径可能不同，每个包可能因为路由器、交换机等原因被再次分片。

最终 tcp/ip 协议，保证了我们收发数据的顺序性和可靠性

#### TCP 包 头结构

就是一个 struct，

0. 前面的头
1. 源端口，目标端口（这里就没有 ip 了，ip 有 IP 头）
2. 32 位序列号
3. 32 位确认号
4. tcp 头部大小（4 位） + 预留 4 位 + 一些开关（关注 syn 位和 ack 位 ）+ 16 位窗口大小
5. 16 位校验值 + 16 位紧急指针
6. tcp 选项
7. data（可选）

每层是 32 位的。

有的数据包里可能是没有 数据（data） 的

#### TCP 数据包收发之前的准备工作

回忆日志操作的步骤：

1. 打开日志文件
2. 多次，反复的往日志文件中写信息
3. 关闭日志文件

tcp 数据的收发是双工的：每端既可以收数据，也可以发数据。

tcp 数据包的发送也分三大部分：

1. 建立 tcp 连接，三次握手(connect)
2. 多次反复的数据收发(read/write)
3. 关闭 tcp 连接(close)

udp 不存在三次握手来建立连接，因此 udp 实际上不存在建立连接的步骤，
udp 数据包是直接发送出去的

#### TCP 三次握手建立连接的过程

客户端理解成一个人，服务器理解为一个人，两个人要用电话通话：

1. 张三（客户端）：你好，李四
2. 李四（服务端）：你好，张三，我是李四
3. 张三：你好，李四

![hand](image/hand.png)

1. 客户端 ---（SYN=1，无 data）---> 服务器
2. 服务器 ---（syn=1，ACK=1，ack=xxx，无 data）---> 客户端
3. 客户端 ---（ACK=1，ack=xxx，无 data）---> 服务器

三次握手成功 建立连接后，才会开始传送 应用层 的数据

#### 为什么 TCP 握手是 三次 而不是 两次

tcp 握手是三次，而不是二次。

比方说诈骗：

1. 假冒公安局（客户端）：你的身份证号是 xxxx，你的名字是 xxxx
2. 你是妖妖灵？那我给你打回去，啪，挂断电话，打回去（笑了）

TCP 三次握手的最主要原因之一： 1. 尽量减少伪造数据包对服务器的攻击

上面的三次中

服务器给客户端发送 ack 包，只有客户端再次返回 ack 相关的包，那么才能建立连接。

因为真正的收发数据，是有成本的。如果伪造了许多假的客户端连接服务器，那么服务区吃不消的。
阻碍了正常的业务。

### telnet 工具使用介绍

是一款命令行方式运行的 客户端 tcp 通讯工具，可以连接到服务器端，
往服务器端发送数据，也可以接收从服务器端发送过来的数据。
有点像上一节课写的客户端代码

```sh
telnet <ip地址> <端口号>
```

可以用来测试服务器端的端口开了没有

### wireshark 监控数据包

在 capture 中，先关闭抓包，然后选择 option，然后设置 filter

```wireshark
host 10.211.55.3 and port 9000
```

![wireshark](image/wireshark.png)

#### TCP 断开的 4 次挥手

这个谁先发送不一定的，看是谁先断开

1. FIN ACK 服务端 --> 客户端
2. ACK 服务端 <-- 客户端
3. FIN ACK 服务端 --> 客户端
4. ACK 服务端 <-- 客户端

![wave](image/wave.png)

## chap5 - 03

### TCP 状态转换

同一个 ip，同一个端口，只能被 bind 一次，
就会调用失败，并且显示错误信息`address already in use`，
就好像，一个班级里，学号一定是不一样的一样。

介绍命令：netstat，是用来显示网络相关信息的，端口状态之类的

`-a`参数，用来显示所有选项

`-n`全部显示成数字

`-p`显示端口对应的策划那个续命

```sh
(base) ┌──(parallels㉿kali-linux-2022-2)-[/media/…/DOCs/cpp/cpplinux/chap5]
└─$ netstat -anp | grep -E 'State|9000' # 这个State表示，是显示状态行
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:9000            0.0.0.0:*               LISTEN      53806/hello5_3_1_se
Proto RefCnt Flags       Type       State         I-Node   PID/Program name     Path
```

`0.0.0.0`表示，本机的任意地址，也就是`serv_addr.sin_addr.s_addr = htonl(INADDR_ANY)`

此时，telnet 连接服务器端，这个时候再次查看网络状态

```sh
(base) ┌──(parallels㉿kali-linux-2022-2)-[/media/…/DOCs/cpp/cpplinux/chap5]
└─$ netstat -anp | grep -E 'State|9000'
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:9000            0.0.0.0:*               LISTEN      53806/hello5_3_1_se
tcp        0      0 10.211.55.3:9000        10.211.55.2:61137       TIME_WAIT   -
tcp        0      0 10.211.55.3:9000        10.211.55.2:61136       TIME_WAIT   -
```

我们用两个客户端连接到服务器，服务器给每个客户端发送一串字符，并关闭客户端。
我们用 netstat 观察：原来的 监听端口一直是【listen】，但是当来了两个连接之后【连接到服务器的 9000 端口】，
虽然这两个连接被 close 掉了，但是产生了两条【TIME_WAIT】信息（【两条】是因为有【两个客户端】）

但是如果我，重启服务器，这个时候会失败，提示是：address already in use，是因为依然有两个【TIME_WAIT】，
确实，我上面在玩那个 telnet 的时候，确实遇到了这个小问题。

现象总结：只要客户端 连接到服务器，并且 服务器把客户端关闭，那么服务端就会产生一条 9000 监听端口的 状态为 TIME_WAIT 的连接。
那么此时重启服务器，bind 返回失败

这个是一个 TCP 转换的问题：《unix 网络变成 卷 1》2.6（TCP 状态转换图）、2.7（专门介绍了 TIME_WAIT 状态）

TCP 状态转换图（一共有 11 中状态），是针对【一个 socket 连接】而言的：
【一个 socket 连接】处于这 11 种状态的一种。

![stat](image/stat.jpeg)

四次挥手，谁主动 close 连接，谁就会给对象发送一个 【FIN 标志位】的一个数据包给对方。
我们的代码中，是服务器发送的。

### TIME_WAIT 详解

TIME_WAIT 状态的产生

主动关闭的一方： ESTABLISHED ---(服务器给客户端发送 FIN)---> FIN_WAIT_1
---(服务器收到了客户端的 ACK)---> FIN_WAIT_2 ---（服务器接收到了客户端的 FIN）---> TIME_WAIT
---(等待 2MSL，大概是 1 ～ 4min)---> CLOSE

被动关闭的一方： ESTABLISHED ---(客户端接收到了服务器的 FIN)---> CLOSE_WAIT
---（再次发送 FIN）---> LAST_ACK ------> CLOSE

这个 TIME_WAIT 就好像是：退出不够利索。当这种状态存在的时候，重启服务器就会失败

![wait](image/wait.png)

《unix 网络编程》对 time_wait 的描述：

上面图的四次挥手中，如果 3th 包丢了，
客户端会在一定时候以后，重新发送 3th 包，
有 time_wait 的存在，那么服务器还有机会接收到这个【重发的 3th 包】。
然后服务器发送 4th 包给客户端，客户端接收到了 4th 包，LAST_ACK 结束--->CLOSE。

（1）可靠的实现 TCP 全双工的终止

如果没有 time_wait，服务端接收到了 fin 包，会给客户端发送 rst 包（而不是 ack 包），
那么客户端收到 rst 包时，某些函数如果没有考虑到这次状态 会报错。（会跳入有限状态机的 IDLE 状态，不正确的假设，鲁棒性）
（而且这个 RST 还有可能会导致数据的丢失）

（1.1）RST 标志

对于每一个 TCP 连接，操作系统是要开辟出来一个 收缓冲区，和一个 发送缓冲区 来处理数据的 收 和 发。
当我们 close 一个 tcp 连接时，如果我们这个发送缓冲区还有数据，那么操作系统会很优雅的把发送缓冲区里的数据发送王壁，
然后再发 fin 包表示连接关闭。

【FIN 四次挥手】是一个优雅的关闭标志，表示正常的 TCP 连接关闭。

【RST 标志】出现这个标志的包，一般都表示：异常关闭; 如果发生了异常，一般都会导致丢失一些数据包。
不是正常的四次挥手关闭，所以如果你这么关闭 tcp 连接，那么主动关闭一方也不会进入 TIME_WAIT。

如果将来用 setsockopt(SO_LINGER) 选项要是开启，【服务器接收到了 RST】如果服务器的发送缓冲区里面有 数据，那么这个数据会被直接丢弃。

（2）允许老的重复的 tcp 数据包在网络中消逝

2MSL 是数据包最长生命周期 的 两倍。
等待存留在网络上的数据包被 路由器等 杀死。
防止再次启动服务器以后，被服务器识别。

### SO_REUSEADDR

`setsockopt(SO_REUSEADDR)`用在服务端 socket 创建之后，bind()之前。

四个能力：

（1）SO_REUSEADDR 允许启动一个监听服务器并绑定器端口，即使 TIME_WAIT 状态存在，服务器 bind()依然能够成功

（2）允许同一个端口上，启动同一个服务器的多个实例，只要每个实例捆绑一个不同的本地 IP 地址即可;

（3）允许同一个进程绑定同一个端口到多个 socket，只要每次捆绑指定不同的本地 IP 地址即可

（4）允许完全重复的绑定：当一个 IP 地址和端口已经绑定到某个 socket 上时，如果传输协议支持，
同样的 ip 地址和端口还可以绑定到另一个 socket 上 Lyiban 来说，本特性仅支持 UDPsocket

**所有 TCP 服务器都应该支持本 socket 选项**，以防止当 socket 处于 TIME_WAIT 时 bind()失败

```c
int listenfd = socket(AF_INET, SOCK_STREAM, 0);

int reuseaddr = 1; // 这里的1表示确实启用该选项，这个函数的接口很奇怪
if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (const void*)&reuseaddr, sizeof(reuseaddr)) == -1) {
    char* peeorinfo = strerror(errno);
    printf("setsockopt(SO_REUSEADDR)返回值为-1, 错误码为:%d, 错误信息为:%s;\n", errno, peeorinfo);
}

bind()
```

## chap5 - 04 - listen()队列、阻塞非阻塞、同步异步

### listen() 队列剖析

listen() 函数：监听端口，用在 TCP 连接中的 服务端 角色

`int listen(int sockfd, int backlog)`

要理解好 backlog 这个参数，我们需要先谈一谈 “监听 socket 队列” 这个问题。

对于一个调用 listen()进行监听的 socket，操作系统会给这个 socket 维护两个队列

1） 未完成连接队列【保存连接用的】

当 client 发送 tcp 连接【三次握手】的第一次【syn 包】给服务器的时候，
服务器就会【未完成队列】中创建一个 跟这个 sync 包对应的一项。
其实，我们可以把这项看成是一个【半连接】，这个半连接状态会从【LISTEN】变为【SYNC——REVD】状态，
同时给 client 返回【第二次握手包 syn ack】。这个时候，其实服务器是在【等待完成第三次握手】
（当然，正常情况下，client 会返回 ack 包）

2） 已完成连接队列【保存连接用的】

当【第三次握手完成】了，这个连接就变成了 ESTABLISHED 状态，每个【已经完成三次握手】的客户端
都放在这个队列中作为一项。

backlog（积压的意思），已完成队列 + 未完成队列 <= backlog

（1）客户端这个 connect()返回的时机：收到【第二次握手包 syn ack】之后就返回了

（2）RTT 是 【未完成队列中任意一项在未完成队列中 滞留的时间】，这个时间取决于客户端和服务器。
RTT 是【服务器接收到 syn】---> 【服务端接收到了 ack】的时间。差不多就是：【2th 3th 握手】的时间。
客户端的 RTT 是【1th 2th 握手】的时间（其实这个关注一下 未完成 就行了）
。如果这三次握手传递速度比较快的话，大概是 187ms。

如果恶意用户，迟迟不发送【第三次握手】，那么【半连接队列】就会满，
半连接队列中的一项，滞留时间是 75s

#### accept() 函数

accept()：就是从【已完成队列】中的【队首】位置取出来一项，返回给进程。
【已完成队列】中的每一项就是一个 socket。

在我们的程序`hello5_3_2_server.c`中，如果【已完成队列】为空，
那么就会【休眠】等待（cpu 时间片切换给其他进程），一直到 已完成队列 中的有一项时，才会被唤醒。
所以，从编程角度，我们要 "尽快" 的用 accept()把已完成队列终端的数据取走！
（这里注意一下，实际上，client 的 accept 返回的比 server 的 accept 返回的早），
这个套接字就代表【已经用三次握手建立起来】的【tcp 连接】，因为 accept() 是从：【已完成队列】中取的数据。

有两种 socket

1. 监听 9000 端口这个 socket，【监听 socket（listenfd）】，只要服务器程序在运行，这个 socket 就应该一直存在
2. 当 client 连接进来，操作系统会为每个【成功建立三次握手】的 client 再创建一个 socket（accept 返回的 socket），随后 server 使用这个 socket(connfd) 与 client 通信

#### syn 攻击【syn flood(溢出)】

如果一个恶意用户，不停地给服务器发送 syn 包，
使得 未完成队列 + 已完成队列 > backlog，
那么有正常用户就连不进来了。（拒绝服务工具 Dos）（如果甚至是分布式，也就是 DDOS，那确实坏菜了）

backlog 进一步被规定了：【已完成队列】中，最大积压数。
但是其实并没有解决根本问题。

当然 backlog 也不能太大，内核对这个有上限。

### 阻塞 与 非阻塞 IO

指的是：调用一个系统函数时，这个函数是否会导致我们的进程进入 sleep

（1）阻塞 IO：
调用一个个呃函数，这个函数就卡在这里，整个程序不往下走了。等待一个事件的发生，
只有事件发生了，这个函数才会往下走

这种阻塞并不好，效率很低。
因为操作系统其实是给每个进程一个时间片，
然而我们没有用完 "时间片" 就休眠了，
我们这个进程就变成了 "活雷锋" 了。

一般我们不希望用【阻塞的方式】来写服务器程序，效率很低。

默认情况下`int listenfd = socket(AF_INET, SOCK_STREAM, 0);`是阻塞的，
所以我们的``

#### 异步 IO

#### IO 复用

#### 思考题

（1）队列满了会忽略

如果 已完成队列 + 未完成队列 > backlog，也就是队列满了，
此时，如果再有一个 client 发送 sync 请求，服务器会怎么反应？

实际上，服务器会忽略这个 syn 包，不给回应。client 这边，发现 syn 没反应，过一段时间会重发。
应该是连着 3 次发送失败，client 的 accept 就会返回失败。

（2）有缓冲区

从连接被扔到【已完成队列】中去，到 accept()从【已完成队列】中取出来，这是有时间差的。

如果 server 还没来得及返回这个 socket，client 就发来数据，这个数据数据就会被保存在：
已经连接的 socket 的接收缓冲区里。
